#!/usr/bin/env perl

# Query a TSV/CSV file using sqlite

use strict;
use warnings;

use IO::All;
use Text::CSV_XS;
use Getopt::Long qw(GetOptions);
use File::Temp qw/ :POSIX /;
use String::Similarity;
use File::Basename;

use DBI;

sub usage
{
  die qq|usage: $0 [-d delim] [-q] [query_string [file [file ...]]]

summary:
 $0 loads the arguments (TSV or CSV files) into a database using one table per
 file then executes the query_string as an SQL query.

 By default the database is an in-memory SQLite database

options:
  -d delim     set the input field delimiter; default: guess using first line
  -q           suppress all informational messages
  --out-delim  set the output field delimiter; default: use the input delimiter

notes:
 - The query string should be valid SQL.
 - If no query string is passed, the query is assumed to be:
     "SELECT * from <table1,table2>"
 - If no files are given as arguments, standard input is read.
 - Each file is read into a table whose name is the basename of the file name,
   ie. if the filename is /home/kmr/test.csv the table name will be "test"
 - The input delimiter guessing compares the number of commas and the number of
   tabs in the first line.  The most common of the two is assumed to be the
   delimiter.

examples:
  - $0 'select * from results where score > 10' scores.tsv
    assuming scores.tsv is:
      name<tab>score
      Fred<tab>20
      ...
  - $0 'select score.name,scores.score
|
}

# if not set with option, use the delimiter of last input file - used for output
# too
my $delimiter = undef;
my $out_delimiter = undef;

my $quiet = 0;

if (!GetOptions('delim|d=s', \$delimiter,
                'out-delim=s', \$out_delimiter,
                'quiet|q' => \$quiet)) {
  usage();
}

$delimiter = "\t" if defined $delimiter && lc $delimiter eq 'tab';

my $sql_query = shift;

if (-e $sql_query) {
  die "$0: $sql_query is a file, the first argument should be an SQL query\n";
}

if (defined $sql_query) {
  $sql_query =~ s/^\s+//;
  $sql_query =~ s/\s+$//;

  if (length $sql_query == 0) {
    # assume "select * from ..."
    $sql_query = undef;
  }
}

my $dbh = DBI->connect('dbi:SQLite:dbname=:memory:', '', '');

my $some_input_has_header = 0;

# make an identifier that's safe for use as an SQLite table or column name
sub make_identifier
{
  my $identifier = lc shift;
  $identifier =~ s/[^a-zA-Z\d]+/_/g;
  return $identifier;
}

sub load_csv
{
  my $file_name = shift;
  my $table_name = shift;

  my $display_file_name;

  if ($file_name eq '-') {
    $display_file_name = 'STDIN';
  } else {
    $display_file_name = $file_name;
  }

  my $io = io($file_name);

  my $first = $io->getline();
  my $second = $io->getline();

  my $csv = Text::CSV_XS->new();

  my $delimiter_to_use = undef;

  if (!defined $delimiter) {
    my $tab_count = ()= $first =~ m/\t/g;
    my $comma_count = ()= $first =~ m/,/g;

    if ($comma_count > $tab_count) {
      $delimiter_to_use = ",";
    } else {
      $delimiter_to_use = "\t";
    }

    $out_delimiter = $delimiter_to_use unless defined $out_delimiter
  } else {
    $delimiter_to_use = $delimiter;
  }

  my $display_delimiter;

  if ($delimiter_to_use eq "\t") {
    $display_delimiter = 'TAB';
  } else {
    $display_delimiter = qq("$delimiter_to_use");
  }

  warn qq(assuming $display_delimiter as the delimiter for $display_file_name\n)
    unless $quiet;
  $csv->sep_char($delimiter_to_use);

  my @first_parsed;

  if ($csv->parse($first)) {
    @first_parsed = $csv->fields();
  } else {
    die "parse failure: ", $csv->error_input(), "\n";
  }

  my @headers;

  my @second_parsed;

  if ($csv->parse($second)) {
    @second_parsed = $csv->fields();
  } else {
    die "parse failure: ", $csv->error_input(), "\n";
  }

  my $similarity =
    similarity(join ("\t", @first_parsed), join ("\t", @second_parsed));

  if (defined $second && $similarity < 0.5) {
    warn "assuming $display_file_name has header line\n"
      unless $quiet;
    @headers = @first_parsed;
    $headers[0] =~ s/^#//;
    # make headers into good sql column names
    map { $_ = make_identifier($_); } @headers;
    @first_parsed = ();
    $some_input_has_header = 1;
  } else {
    warn "assuming input from $display_file_name has no header line, " .
      "using columns names like 'c1', 'c2', ...\n" unless $quiet;
    for (my $i = 1; $i <= @first_parsed; $i++) {
      push @headers, "c$i";
    }
  }

  my $columns_str = join (", ", map { "$_ text" } @headers);

  my $create_table_sql = "CREATE table $table_name ($columns_str)";

  my $sth = $dbh->prepare($create_table_sql);
  $sth->execute();

  my $add_row_sql = "insert into $table_name values (" .
    join(",", map { "?" } @headers) . ")";
  $sth = $dbh->prepare($add_row_sql);

  if (@first_parsed) {
    $sth->execute(@first_parsed);
  }

  if (defined $second) {
    if ($csv->parse($second)) {
      $sth->execute($csv->fields());
    } else {
      die "parse failure: ", $csv->error_input(), "\n";
    }

    while (defined (my $fields = $csv->getline($io))) {
      $sth->execute(@$fields);
    }
  }
}

my @table_names = ();

if (@ARGV) {
  for (my $i = 0; $i < @ARGV; $i++) {
    my $table_name = make_identifier(basename($ARGV[$i], '.csv', '.tsv'));
    push @table_names, $table_name;
    load_csv($ARGV[$i], $table_name);
  }
} else {
  my $table_name = 't1';
  push @table_names, $table_name;
  load_csv('-', $table_name);
}

my $all_tables_str = join ',', @table_names;

if (!defined $sql_query) {
  $sql_query = "SELECT * FROM $all_tables_str";
} else {
  my $select_from_re = qr/^\s*select .* from .*/i;

  if ($sql_query !~ $select_from_re) {
    $sql_query = "SELECT * FROM $all_tables_str WHERE $sql_query";
    warn "added missing SELECT ... FROM ... WHERE to query string\n"
    unless $quiet;
  }
}

my $sth = $dbh->prepare($sql_query);
if (!defined $sth) {
  die "$0: preparing query failed: ", $dbh->errstr(), "\n";
}

$sth->execute();

my $out_csv = Text::CSV_XS->new({ eol => "\n" });
$out_csv->sep_char($out_delimiter);

if ($some_input_has_header) {
  # use a header line for output if there was one for input
  warn "using header line for output because an input file had a header line\n"
    unless $quiet;
  my @field_names = @{ $sth->{NAME} };

  $out_csv->print(\*STDOUT, \@field_names);
}

while (my @data = $sth->fetchrow_array()) {
  $out_csv->print(\*STDOUT, \@data);
}
